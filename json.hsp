#ifdef HSP_JSON_FILE_GUARD
#else
#define global HSP_JSON_FILE_GUARD 0

#const global JSON_TYPENAME_PRIMITIVE 0
#const global JSON_TYPENAME_OBJECT 1
#const global JSON_TYPENAME_ARRAY 2

#module hash_util
    #const global hash_max_value 256
    #defcfunc Hash_string str value_
        hash_value_ = value_
        result = 0
        flag = 0
        repeat strlen(hash_value_)
            poke result, 0, peek(result, 0) ^ peek(hash_value_, cnt)
        loop
        return result

    #defcfunc Hash var hash_value
        switch vartype(hash_value)
            case 2 // string
                return Hash_string(hash_value)
            swbreak
            case 3 // double
                return peek(hash_value,6)
                swbreak 
            case 4 // int
                return peek(hash_value,0)
                swbreak
        default
            swbreak
        swend
        return 0
#global
#module JSON_Map_KV value, type, key
    #modinit str key_
        key = key_
        return

    #modcfunc local getMapKey
        return key
#global

#module JSON_Map_KV_list values, ElementCount
    #modinit
        ElementCount = 0
        return

    #modcfunc local getSize
        return ElementCount

    #modfunc create_KV str key
        ElementCount++
        newmod values,JSON_Map_KV, key
        return

    #modfunc local getKV_index int index, var out
        out = values(index)
        return

    #modfunc getKV var out, str key_
        out_f = 1
        if (ElementCount != 0) {
            repeat ElementCount /* なんかforeach にすると動かないんだけどなんで？ */
                if key_ = getMapKey@JSON_Map_KV(values(cnt)) {
                    out = values(cnt)
                    out_f = 0
                    break
                }
            loop
        }
        if (out_f = 1) {
            dialog "Error in Reading JSON: key \"" + key_ + "\" not found", 1
        }
        return
#global

#module JSON_Object type, child, element_count
    #modinit
        type = JSON_TYPENAME_OBJECT
        element_count = 0
        repeat hash_max_value + 1
            newmod child,JSON_Map_KV_list
        loop
        return

    #modfunc insertPrimitiveValueR str key, var value, var out
        key_hash = Hash_string(key)
        create_KV child(key_hash), key
        getKV child(key_hash), out, key
        create_primitive_val out,value
        element_count++
        return

    #modfunc insertMapR str key, var out
        key_hash = Hash_string(key)
        create_KV child(key_hash), key
        getKV child(key_hash), out, key
        create_JSON_Map out
        element_count++
        return

    #modfunc insertArrayR str key, var out
        key_hash = Hash_string(key)
        create_KV child(key_hash), key
        getKV child(key_hash), out, key
        create_JSON_Array out
        element_count++
        return

    #modfunc insertPrimitiveValue str key, var value
        insertPrimitiveValueR thismod, key, value, tmp
        return

    #modfunc insertMap str key
        insertMapR thismod, key, tmp
        return

    #modfunc insertArray str key
        insertArrayR thismod, key, tmp
        return

    #modfunc local get var out_, str key_
        getKV child(Hash_string(key_)), out_kv, key_
        getValue@JSON_Value_wrapper out_kv, out_
        return

    #modcfunc foreach_object var key_out, var value_out, var loop_var
        hash_index = peek(loop_var, 0)
        KV_index = lpeek(loop_var, 1)
        total_count = lpeek(loop_var,5)
        if (total_count = element_count) {
            return 0
        }
        repeat
            if (getSize@JSON_Map_KV_list(child(hash_index)) <= KV_index) {
                hash_index++
                KV_index = 0
            } else {
                break
            }
        loop
        getKV_index@JSON_Map_KV_list child(hash_index), KV_index, out
        key_out = getMapKey@JSON_Map_KV(out)
        getValue@JSON_Value_wrapper out, value_out
        KV_index++
        total_count++
        poke loop_var, 0, hash_index
        lpoke loop_var,1, KV_index
        lpoke loop_var, 5, total_count
        return 1
    
    #modcfunc local dump_json_map local dump_result, local foreach_count
        dump_result = "{"
        json_start_foreach foreach_count
        repeat
            if (foreach_object(thismod, key, val, foreach_count) = 0) { break }
            if (cnt != 0) {
                dump_result = dump_result + ","
            }
            dump_result = dump_result + dump@JSON(key) + ":" + dump@JSON(val)
        loop
        dump_result = dump_result + "}"
        return dump_result

#global

#module JsonArrayChild value, type
#global

#module Json_Array type,child, ElementsCount
    #modinit
        type = JSON_TYPENAME_ARRAY
        ElementsCount = 0
        return

    #modfunc pushPrimitiveValue var value
        newmod child, JsonArrayChild
        create_primitive_val child(ElementsCount), value
        ElementsCount++
        return (ElementsCount - 1) // return index
    
    #modfunc pushMap
        newmod child, JsonArrayChild
        create_JSON_Map child(ElementsCount)
        ElementsCount++
        return (ElementsCount - 1) // return index

    #modfunc pushArray
        newmod child, JsonArrayChild
        create_JSON_Array child(ElementsCount)
        ElementsCount++
        return (ElementsCount - 1) // return index
        
    #modfunc local get var out_, int index
        getValue@JSON_Value_wrapper child(index), out_
        return

    #modcfunc foreach_array var value_out, var loop_var
        total_count = lpeek(loop_var,0)
        if (total_count >= ElementsCount) {
            return 0
        }
        get@Json_Array thismod,value_out, total_count
        lpoke loop_var, 0, total_count+1
        return 1
    
    #modcfunc local dump_json_array local dump_result, local foreach_count
        dump_result = "["
        json_start_foreach foreach_count
        repeat
            if (foreach_array(thismod, val, foreach_count) = 0) { break }
            if (cnt != 0) {
                dump_result = dump_result + ","
            }
            dump_result = dump_result + dump_json(val)
        loop
        dump_result = dump_result + "]"
        return dump_result
#global

#module JSON_Value_wrapper value, type
    #modfunc create_primitive_val var value_
        value = value_
        return

    #modfunc create_JSON_Map 
        newmod value,JSON_Object
        return

    #modfunc create_JSON_Array
        newmod value,Json_Array
        return

    #modfunc local getValue var out
        out = value
        return
#global
#module JSON_container_util type
    #modcfunc getJsonContainerType
        return type

    #defcfunc dump_json_container var mod_
        if (getJsonContainerType(mod_) = JSON_TYPENAME_OBJECT) { // object
            return dump_json_map@JSON_Object(mod_)
        } else : if (getJsonContainerType(mod_) = JSON_TYPENAME_ARRAY) {
            return dump_json_array@Json_Array(mod_)
        }
        return         
    #deffunc json_start_foreach var loop_val
        sdim loop_val, 9
        return
#global

#module JSON
    #const global JSON_CRATE_EMPTY 0
    #const global JSON_CRATE_PARSE 1

    #deffunc local parse var out, str json_data_
        newmod child, Json_Array
        parse_r json_data_, -1, child
        get@Json_Array child, out,0
        return

    #defcfunc local parse_value 
        string_buf = ""
        str_length = strlen(json_data)
        current_char = strmid(json_data,count,1)
        current_char_code = peek(current_char,0)
        if (current_char = "\"") {
            repeat
            count++
            if (count >= str_length) {
                break
            }
            current_char = strmid(json_data,count,1)
            if (current_char = "\\") {
                count++
                current_char = strmid(json_data, count,1)
                if (current_char = "\"") {
                    string_buf = string_buf + "\""
                } else if (current_char = "\\") {
                    string_buf = string_buf + "\\"
                } else if (current_char = "/") {
                    string_buf = string_buf + "/"
                } else if (current_char = "n") {
                    string_buf = string_buf + "\n"
                } else if (current_char = "r") {
                    string_buf = string_buf + "\r"
                } else if (current_char = "t") {
                    string_buf = string_buf + "\t"
                } else {
                    // ??
                }
                continue
            }
            if (current_char = "\"") {
                break 
            }
            string_buf = string_buf + current_char
            loop
            return string_buf
        } else : if (('0' <= current_char_code and current_char_code <= '9') or current_char = "-") { // number
        double_flag = 0
        minus_flag = 1
        if (strmid(json_data,count,1) = "-") {
            minus_flag = -1
            count++
        }
        repeat
            if (count >= str_length) {
                break
            }
            current_char = strmid(json_data,count,1)
            if (current_char = ".") {
                double_flag = 1
            }
            current_char_code = peek(current_char,0)
            if ('0' <= current_char_code and current_char_code <= '9') {
                string_buf = string_buf + current_char
            } else {
                count--
                break
            }
            count++
        loop
            if (double_flag = 1) {
                return double(string_buf) * minus_flag
            } else {
                return int(string_buf) * minus_flag
            }
        }
        v = "\r"
        print peek(v,0)
        stop

    // parent: container
    #deffunc local parse_r str json_str_, int count_, var current_, local current_container
        json_data = json_str_
        current_container = current_
        count = count_

        #enum FINDING_VALUE = 0
        #enum FINDING_KEY
        #enum FINGING_COMMA_OR_BRACKET_CLOSE
        #enum FINDINF_CORON
        if (getJsonContainerType(current_container) = JSON_TYPENAME_OBJECT) {
            parse_phase = FINDING_KEY
        } else {
            parse_phase = FINDING_VALUE
        }
        // 1 => map
        // 2 => array
        key = ""
        str_length = strlen(json_data)
        repeat
            count++
            if (count >= str_length) {
                break
            }

            current_char = peek(json_data, count)
            if (current_char = ' ' or current_char = 10 /*LF*/ or current_char = 13 /*CR*/ or current_char = '\t')  {
                continue
            }
        if (current_char = ':' and parse_phase = 3) {
            parse_phase = FINDING_VALUE
            continue
        }

        if (current_char = ',' and parse_phase = FINGING_COMMA_OR_BRACKET_CLOSE) {
            if (getJsonContainerType(current_container) = 1) {
                parse_phase = FINDING_KEY
            } else {
                parse_phase = FINDING_VALUE
            }
            continue
        }
        if (current_char = '{') {
            nest_level++
            if (getJsonContainerType(current_container) = JSON_TYPENAME_OBJECT) {
                if ( parse_phase = FINDING_KEY ) {
                    dialog "parse error: expext key {}"
                }
                insertMapR current_container, key, new_nest_kv
                getValue@JSON_Value_wrapper new_nest_kv, new_nest
                parse_r json_data, count, new_nest
            } else { // array
                pushMap current_container
                get@Json_Array current_container, new_nest, stat
                parse_r json_data, count, new_nest
            }
            parse_phase = 2
            continue
        }
        if (current_char = '[') {
            nest_level++
            if (getJsonContainerType(current_container) = JSON_TYPENAME_OBJECT) {    
                if ( parse_phase = FINDING_KEY ) {
                    dialog "parse error: expext key in insert []"
                }
                insertArrayR current_container, key, new_nest_kv
                getValue@JSON_Value_wrapper new_nest_kv, new_nest
                parse_r json_data, count, new_nest
            } else { // array
                pushArray current_container
                get@Json_Array current_container, new_nest, stat
                parse_r json_data, count, new_nest
            }
            parse_phase = FINGING_COMMA_OR_BRACKET_CLOSE
            continue
        }
        if (current_char = '}' or current_char = ']') {
            if (getJsonContainerType(current_container) = JSON_TYPENAME_PRIMITIVE and parse_phase != 0) {
                dialog "parse error: unexpected } or ]"
            }
            break
        }

        read_str = parse_value()
        if (getJsonContainerType(current_container) = JSON_TYPENAME_OBJECT) {
            if (parse_phase = FINDING_KEY) {
                key = read_str
                parse_phase = FINDINF_CORON
            } else {
                insertPrimitiveValue current_container, key, read_str
                parse_phase = FINGING_COMMA_OR_BRACKET_CLOSE
                continue
            }
        } else {
            pushPrimitiveValue current_container, read_str
            parse_phase = FINGING_COMMA_OR_BRACKET_CLOSE
        }
        loop
        return

    #defcfunc local dump var value, local local_val
        local_val = value
        if (vartype(local_val) = 5) {
            return dump_json_container(local_val)
        }
        if (vartype(local_val) = 2)  {// string
            return "\"" + local_val + "\""
        }
        return str(local_val)

#global
#endif
