#const true 1
#const false 0

#addition "WrapCall.as"
#ifdef HSP_JSON_FILE_GUARD
#else
#define global HSP_JSON_FILE_GUARD 0
#module hash_util
    #const global hash_max_value 256
    #defcfunc Hash var hash_value
        switch vartype(hash_value)
            case 2 // string
                result = 0
                flag = 0
                repeat strlen(hash_value)
                    poke result, 0, peek(result, 0) ^ peek(hash_value, cnt)
                loop
                return result
            swbreak
            case 3 // double
                return peek(hash_value,6)
                swbreak 
            case 4 // int
                return peek(hash_value,0)
                swbreak
        default
            swbreak
        swend
        return 0
#global

#const global JSON_TYPENAME_PRIMITIVE 0
#const global JSON_TYPENAME_MAP 1
#const global JSON_TYPENAME_ARRAY 2

#module JSON_Map_KV value, type, key
    #modinit var key_
        key = key_
        return

    #modcfunc local getMapKey
        return key
#global

#module JSON_Map_KV_list values, ElementCount
    #modinit
        ElementCount = 0
        return

    #modcfunc local getSize
        return ElementCount

    #modfunc create_KV var key
        ElementCount++
        newmod values,JSON_Map_KV, key
        return

    #modfunc local getKV_index int index, var out
        out = values(index)
        return

    #modfunc getKV var out,var key_
        out_f = 1
        if (ElementCount != 0) {
            repeat ElementCount /* なんかforeach にすると動かないんだけどなんで？ */
                if key_ = getMapKey@JSON_Map_KV(values(cnt)) {
                    out = values(cnt)
                    out_f = 0
                    break
                }
            loop
        }
        if (out_f = 1) {
            if (vartype(key_) = 2) { // string
                dialog "Error in Reading JSON: key \"" + key_ + "\" not found", 1
            } else {
                dialog "Error in Reading JSON: key " + key_ + " not found", 1
            }
        }
        return
#global

#module JSON_Object type, child, element_count
#modinit
    type = 1
    element_count = 0
    repeat hash_max_value + 1
        newmod child,JSON_Map_KV_list
    loop
    return

#modfunc insertPrimitiveValueR var key, var value, var out
    key_hash = Hash(key)
    create_KV child(key_hash), key
    getKV child(key_hash), out, key
    create_primitive_val out,value
    element_count++
    return

#modfunc insertMapR var key, var out
    key_hash = Hash(key)
    create_KV child(key_hash), key
    getKV child(key_hash), out, key
    create_JSON_Map out
    element_count++
    return

#modfunc insertArrayR var key, var out
    key_hash = Hash(key)
    create_KV child(key_hash), key
    getKV child(key_hash), out, key
    create_JSON_Array out
    element_count++
    return

#modfunc insertPrimitiveValue var key, var value
    insertPrimitiveValueR thismod, key, value, tmp
    return

#modfunc insertMap var key
    insertMapR thismod, key, tmp
    return

#modfunc insertArray var key
    insertArrayR thismod, key, tmp
    return

#modfunc local get var out_, str key_
    key_var = key_
    getKV child(Hash(key_var)), out_kv, key_var
    getValue@JSON_Value_wrapper out_kv, out_
    return

#modcfunc foreach_object var key_out, var value_out, var loop_var
    hash_index = peek(loop_var, 0)
    KV_index = lpeek(loop_var, 1)
    total_count = lpeek(loop_var,5)
    if (total_count = element_count) {
        return 0
    }
    repeat
        if (getSize@JSON_Map_KV_list(child(hash_index)) <= KV_index) {
            hash_index++
            KV_index = 0
        } else {
            break
        }
    loop
    getKV_index@JSON_Map_KV_list child(hash_index), KV_index, out
    key_out = getMapKey@JSON_Map_KV(out)
    getValue@JSON_Value_wrapper out, value_out
    KV_index++
    total_count++
    poke loop_var, 0, hash_index
    lpoke loop_var,1, KV_index
    lpoke loop_var, 5, total_count
    return 1
    
    #modcfunc local dump_json_map local dump_result, local foreach_count
        dump_result = "{"
        json_start_foreach foreach_count
        repeat
            if (foreach_object(thismod, key, val, foreach_count) = 0) { break }
            if (cnt != 0) {
                dump_result = dump_result + ","
            }
            dump_result = dump_result + dump_json(key) + ":" + dump_json(val)
        loop
        dump_result = dump_result + "}"
        return dump_result

#global

#module JsonArrayChild value, type
#global

#module Json_Array type,child, ElementsCount
    #modinit
        type = 2
        ElementsCount = 0
        return

    #modfunc pushPrimitiveValue var value
        newmod child, JsonArrayChild
        create_primitive_val child(ElementsCount), value
        ElementsCount++
        return (ElementsCount - 1) // return index
    
    #modfunc pushMap
        newmod child, JsonArrayChild
        create_JSON_Map child(ElementsCount)
        ElementsCount++
        return (ElementsCount - 1) // return index

    #modfunc pushArray
        newmod child, JsonArrayChild
        create_JSON_Array child(ElementsCount)
        ElementsCount++
        return (ElementsCount - 1) // return index
        
    #modfunc local get var out_, int index
        getValue@JSON_Value_wrapper child(index), out_
        return

    #modcfunc foreach_array var value_out, var loop_var
        total_count = lpeek(loop_var,0)
        if (total_count >= ElementsCount) {
            return 0
        }
        get@Json_Array thismod,value_out, total_count
        lpoke loop_var, 0, total_count+1
        return 1
    
    #modcfunc local dump_json_array local dump_result, local foreach_count
        dump_result = "["
        json_start_foreach foreach_count
        repeat
            if (foreach_array(thismod, val, foreach_count) = 0) { break }
            if (cnt != 0) {
                dump_result = dump_result + ","
            }
            dump_result = dump_result + dump_json(val)
        loop
        dump_result = dump_result + "]"
        return dump_result
#global

#module JSON_Value_wrapper value, type
    #modfunc create_primitive_val var value_
        value = value_
        return

    #modfunc create_JSON_Map 
        newmod value,JSON_Object
        return

    #modfunc create_JSON_Array
        newmod value,Json_Array
        return

    #modfunc local getValue var out
        out = value
        return
#global
#module JSON_container_util type
    #modcfunc getJsonContainerType
        return type

    #defcfunc dump_json_container var mod_
        if (getJsonContainerType(mod_) = 1) { // map
            return dump_json_map@JSON_Object(mod_)
        } else {
            return dump_json_array@Json_Array(mod_)
        }
        return 

    #defcfunc dump_json var value, local local_val
        local_val = value
        if (vartype(local_val) = 5) {
            return dump_json_container(local_val)
        }
        if (vartype(local_val) = 2)  {// string
            return "\"" + local_val + "\""
        }
        return str(local_val)
        
    #deffunc json_start_foreach var loop_val
        sdim loop_val, 9
        return
#global

#module JSON child
#const global JSON_CRATE_EMPTY 0
#const global JSON_CRATE_PARSE 1

#modinit int mode, str json_data_
    if (mode = JSON_CRATE_PARSE) {
        newmod child, Json_Array
        parse json_data_, -1, child
    }
    return

#modfunc local get var out
    get@Json_Array child,out,0
    return  
// parse "value"

#deffunc parse_str_test str input_
    json_data = input_
    str_length = strlen(json_data)
    count = 0
    repeat 
        count++
        if (count >= str_length) {
            break
        }
        print "aa :  " +strmid(json_data,count,1)
        if (strmid(json_data,count,1) = "\"") {
            print parse_string()
        }
    loop
    return

#defcfunc local parse_number

#defcfunc local parse_value 
    string_buf = ""
    str_length = strlen(json_data)
    current_char = strmid(json_data,count,1)
    current_char_code = peek(current_char,0)
    if (current_char = "\"") {
        repeat
        count++
        if (count >= str_length) {
            break
        }
        current_char = strmid(json_data,count,1)
        if (current_char = "\\") {
            count++
            current_char = strmid(json_data, count,1)
            if (current_char = "\"") {
                string_buf = string_buf + "\""
            } else if (current_char = "\\") {
                string_buf = string_buf + "\\"
            } else if (current_char = "/") {
                string_buf = string_buf + "/"
            } else if (current_char = "n") {
                string_buf = string_buf + "\n"
            } else if (current_char = "r") {
                string_buf = string_buf + "\r"
            } else if (current_char = "t") {
                string_buf = string_buf + "\t"
            } else {
                // ??
            }
            continue
        }
        if (current_char = "\"") {
            break 
        }
        string_buf = string_buf + current_char
        loop
        return string_buf
    } else : if (('0' <= current_char_code and current_char_code <= '9') or current_char = "-") { // number
    double_flag = 0
    minus_flag = 1
    if (strmid(json_data,count,1) = "-") {
        minus_flag = -1
        count++
    }
    repeat
        if (count >= str_length) {
            break
        }
        current_char = strmid(json_data,count,1)
        if (current_char = ".") {
            double_flag = 1
        }
        current_char_code = peek(current_char,0)
        if ('0' <= current_char_code and current_char_code <= '9') {
            string_buf = string_buf + current_char
        } else {
            count--
            break
        }
        count++
    loop
        if (double_flag = 1) {
            return double(string_buf) * minus_flag
        } else {
            return int(string_buf) * minus_flag
        }
    }
    v = "\r"
    print peek(v,0)
    stop

// parent: container
#deffunc local parse str json_str_, int count_, var current_, local current_container
    json_data = json_str_
    current_container = current_
    count = count_

    // 0 => found key
    // 1 => not found key
    // 2 => wait for "," or bracket close
    // 3 => wait for ":"
    if (getJsonContainerType(current_container)  = 1) {
        key_empty_flag = 1
    } else {
        key_empty_flag = 0
    }
    //  print "nest!"
    // 1 => map
    // 2 => array
    key = ""
    str_length = strlen(json_data)
    repeat
        count++
        if (count >= str_length) {
            break
        }
        
        current_char = peek(json_data, count)
        if (current_char = ' ' or current_char = 10 /*LF*/ or current_char = 13 /*CR*/ or current_char = '\t')  {
            continue
        }
    if (current_char = ':' and key_empty_flag = 3) {
        key_empty_flag = 0
        continue
    }

    if (current_char = ',' and key_empty_flag = 2) {
        if (getJsonContainerType(current_container) = 1) {
            key_empty_flag = 1
        } else {
            key_empty_flag = 0
        }
        continue
    }
    if (current_char = '{') {
        //print "nest1{ : " + count
        nest_level++
        if (getJsonContainerType(current_container) = 1) {
            if ( key_empty_flag = 1 ) {
                dialog "parse error: expext key {}"
            }
            insertMapR current_container, key, new_nest_kv
            getValue@JSON_Value_wrapper new_nest_kv, new_nest
            parse json_data, count, new_nest
        } else { // array
            pushMap current_container
            get@Json_Array current_container, new_nest, stat
            parse json_data, count, new_nest
        }
        key_empty_flag = 2
        continue
    }
    if (current_char = '[') {
        //print "nest1[ : " + count
        nest_level++
        if (getJsonContainerType(current_container) = 1) {    
            if ( key_empty_flag = 1 ) {
                dialog "parse error: expext key in insert []"
            }
            insertArrayR current_container, key, new_nest_kv
            getValue@JSON_Value_wrapper new_nest_kv, new_nest
            parse json_data, count, new_nest
        } else { // array
            pushArray current_container
            get@Json_Array current_container, new_nest, stat
            parse json_data, count, new_nest
        }
        key_empty_flag = 2
        continue
    }
    if (current_char = '}' or current_char = ']') {
        if (getJsonContainerType(current_container) = 0 and key_empty_flag != 0) {
            dialog "parse error: unexpected } or ]"
        }
        if (getJsonContainerType(current_container) = 1) {
            key_empty_flag = 1
        } else {
            key_empty_flag = 0
        }
        break
    }

    read_str = parse_value()
    if (getJsonContainerType(current_container) = 1) {
        if (key_empty_flag = 1) {
            key = read_str
            key_empty_flag = 3
        } else {
            insertPrimitiveValue current_container, key, read_str
            key_empty_flag = 2
            continue
        }
    } else {
        pushPrimitiveValue current_container, read_str
        key_empty_flag = 2
    }
    continue

loop
return
#global
#endif
